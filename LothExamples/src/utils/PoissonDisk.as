package utils {	// import flash.display.DisplayObject;	import flash.display.BitmapData;	// import flash.display.Sprite;	import flash.display.Shape;	import flash.geom.Vector3D;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.geom.Point;	public class PoissonDisk {		private var _list : Vector.<Vector3D>;		private var _width : uint ;		private var _height : uint ;		private var _maxPoints : int ;		private var _radiusMin : Number ;		private var _radiusMax : Number ;		private var _maxFails : int ;		private var _posY : int ;		private var _hitMap : BitmapData;		private var _distanceMap : BitmapData;		private var _nr : int;		private var _pi2 : Number = 2 * Math.PI;		public function PoissonDisk(DistanceMap : BitmapData = null, Max : uint = 200, Fail : uint = 200, Rmin : uint = 20, Rmax : uint = 200) {			_distanceMap = DistanceMap;			// _hitMap = HitMap;			_width = DistanceMap.width ;			_height = DistanceMap.height;			_maxPoints = Max;			_maxFails = Fail;			_radiusMin = Rmin;			_radiusMax = Rmax;			_posY = 0;			createPoints();		}		/**		 * Draw map reference		 */		/*public function drawMap(map : DisplayObject, transparent : Boolean = false) : BitmapData {		var m : Matrix = new Matrix();		var Fmap : BitmapData = new BitmapData(_width, _height, transparent, 0);		if (map as Sprite) Fmap.draw(map, m);		if (map as BitmapData) Fmap = BitmapData(map);		return Fmap;		}*/		/**		 * Generate vector of point from poisson disk methode		 */		public function createPoints() : void {			if ( _hitMap == null ) _hitMap = new BitmapData(_width, _height, true, 0);			_hitMap.lock();			_nr = 0;			_list = new Vector.<Vector3D>();			var pp : Vector3D;			var bmdCircle : BitmapData = new BitmapData(_radiusMax * 2, _radiusMax * 2, true, 0);			var clearRect : Rectangle = new Rectangle(0, 0, _radiusMax * 2, _radiusMax * 2);			var matrixCircle : Matrix = new Matrix();			var pZero : Point = new Point(0, 0);			var pCircle : Point = new Point(0, 0);			var numFailed : int = 0;			var circle : Shape = new Shape();			circle.graphics.clear();			circle.graphics.beginFill(0xFFFFFF);			circle.graphics.drawCircle(_radiusMax, _radiusMax, _radiusMax);			circle.graphics.endFill();			while ( _nr < _maxPoints && numFailed < _maxFails) {				if ( _nr == 0 ) pp = createfirstPoint();				else pp = createRandomAround(pp);				matrixCircle.a = matrixCircle.d = pp.z / _radiusMax;				matrixCircle.tx = matrixCircle.ty = _radiusMax - pp.z;				bmdCircle.fillRect(clearRect, 0);				bmdCircle.draw(circle, matrixCircle);				pCircle.x = pp.x - _radiusMax;				pCircle.y = pp.y - _radiusMax;				if (!_hitMap.hitTest(pZero, 0xFF, bmdCircle, pCircle)) {					// point accepted					matrixCircle.tx = pp.x - pp.z;					matrixCircle.ty = pp.y - pp.z;					_hitMap.draw(circle, matrixCircle);					_list[_nr] = pp;					_nr++;					numFailed = 0;				} else {					// too close					numFailed++;				}			}			_hitMap.unlock();			bmdCircle.dispose();		}		/**		 * Delete hit point		 */		public function clearHitMap() : void {			if ( _hitMap != null ) {				_hitMap.dispose();				_hitMap = null;			}		}		/**		 * Create basic point		 */		private function createfirstPoint() : Vector3D {			var ranX : int = int(Math.random() * _width);			var ranY : int = int(Math.random() * _height);			var r : int;			if ( _distanceMap == null ) r = _radiusMin + (Math.random() * (_radiusMax - _radiusMin));			else {				r = (_distanceMap.getPixel(ranX, ranY)) >> 16;				r = _radiusMin + ((_radiusMax - _radiusMin) * (r / 255));			}			return new Vector3D(ranX, ranY, r);		}		/**		 * Create point around		 */		private function createRandomAround(p_point : Vector3D) : Vector3D {			var ran : Number = Math.random();			var r : int = int(p_point.z + _radiusMax * (ran));			ran = Math.random();			var a : Number = _pi2 * (ran);			var newX : int = int(p_point.x + (r * Math.sin(a)));			var newY : int = int(p_point.y + (r * Math.cos(a)));			if ( newX <= 0 || newX >= _width ) newX = ran * _width;			if ( newY <= 0 || newY >= _height ) newY = ran * _height;			if ( _distanceMap == null ) r = _radiusMin + (Math.random() * (_radiusMax - _radiusMin));			else {				r = _distanceMap.getPixel(newX, newY) >> 16;				r = _radiusMin + ((_radiusMax - _radiusMin) * (r / 255));			}			return new Vector3D(newX, newY, r);		}		/**		 * Settings		 */		/*public function get list() : Vector.<Vector3D> {		return _list;		}		public function set list(b : Vector.<Vector3D>) : void {		_list = b;		}		public function get width() : uint {		return _width;		}		public function set width(b : uint) : void {		_width = b;		}		public function get height() : uint {		return _height;		}		public function set height(b : uint) : void {		_height = b;		}		public function get maxPoints() : int {		return _maxPoints;		}		public function set maxPoints(b : int) : void {		_maxPoints = b;		}		public function get maxFails() : int {		return _maxFails;		}		public function set maxFails(b : int) : void {		_maxFails = b;		}		public function get radiusMin() : Number {		return _radiusMin;		}		public function set radiusMin(b : Number) : void {		_radiusMin = b;		}		public function get radiusMax() : Number {		return _radiusMax;		}		public function set radiusMax(b : Number) : void {		_radiusMax = b;		}		public function get hitMap() : BitmapData {		return _hitMap;		}		public function set hitMap(b : BitmapData) : void {		_hitMap = b;		}		public function get distanceMap() : BitmapData {		return _distanceMap;		}		public function set distanceMap(b : BitmapData) : void {		_distanceMap = b;		}*/	}}